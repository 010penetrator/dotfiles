" vim: ts=2 sts=2 sw=2 ft=vim
" vi: noswapfile
" Configure the Vim editor
" and NeoVim as well..

""""""""""""""""""""""""""""""""
""        Initializing:       ""
""""""""""""""""""""""""""""""""

set nocompatible
set termguicolors
compiler gcc
set makeprg=make
" set makeprg=gcc\ %:p\ -o\ %:p:h/bin
" set makeprg=g++\ %:p\ -o\ %:p:h/bin
" set makeprg=sh\ my_make.sh
set path=.,**
" set wildignore=*.swp
" let vstatus = 300

""  Useful memories  ""
" help i_ctrl-
" help map-which-keys
" currfile=%\ mainbin
" let $BROWSER = 'luakit'
" .w !bash  "exec current line with bash
" %s/^\(\s\)\+$//g | "clean space lines
" s/\(|\|\\\)/\\\1/g "screen backslashes for saving vim command
" %s/\([\[\]]\) [\[\]]/\1\1/g " change '[ [' to '[[' and '] ]' to ']]'
" exec  "!"  . @"  "exec yank buffer
" read !ls -la  "paste shell output
" g/.\{20,\}/ exec "normal gqgq" | noh " format longer lines
" autocmd WinNew * set numberwidth=2 winheight=7
" Check lightline themes here
" read !ls $PLUGDIR/lightline.vim/autoload/lightline/colorscheme
" :%!xxd "re-open as hex

""""""""""""""""""""""""""""""""
""         Settings:          ""
""""""""""""""""""""""""""""""""

if exists("g:loaded_lightline")
  if !exists("g:lightline")
    let g:lightline = { }
  endif
  let g:lightline.active = { 'left': [ [ 'mode', 'paste' ], [ 'readonly', 'modified', 'gitbranch', 'relativepath' ] ] }
  let g:lightline.component_function =  { 'gitbranch': 'FugitiveHead' }
endif

let g:completion_enable_auto_popup = 1
let g:goyo_width = "66%"
let g:goyo_height = "95%"

let g:startify_bookmarks = [ {'s': '~/.sh'}, '/ln/lo/cur/' ]
let g:startify_files_number = 8
let g:startify_lists = [
            \ { 'type': 'files',     'header': ['   MRU']            },
            \ { 'type': 'sessions',  'header': ['   Sessions']       },
            \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
            \ { 'type': 'commands',  'header': ['   Commands']       },
            \ ]
            " \ { 'type': 'dir',       'header': ['   MRU '. getcwd()] },
let g:startify_session_dir = $VICONFDIR . "/session"

if !isdirectory(g:startify_session_dir) 
  call mkdir(g:startify_session_dir, '', 0770) 
endif

set encoding=UTF-8
set fileencodings=ucs-bom,utf-8,default,cp1251,latin1
set langmap=ФИСВУАПРШОЛДЬТЩЗЙКЫЕГМЦЧНЯ;ABCDEFGHIJKLMNOPQRSTUVWXYZ,фисвуапршолдьтщзйкыегмцчня;abcdefghijklmnopqrstuvwxyz
" set keymap=russian-jcukenwin
set colorcolumn=
set cursorline
set updatetime=8000
set noequalalways
set winheight=7
set guicursor=n-v-c:block,i-ci:block,r-cr-o:hor20
" set iminsert=0
" set imsearch=0
" set nofoldenable    " disable folding
set tabstop=2 softtabstop=2 shiftwidth=4 expandtab smarttab smartindent
set textwidth=0 wrapmargin=0
set invlinebreak
set breakindent
set breakindentopt=shift:2
set showbreak=↳
set sidescroll=24
" set list lcs=tab:\┆\۰
	" ls tab sample
set list lcs=tab:\┆\ 
set scrolloff=5
set number
set numberwidth=2
set signcolumn=yes
set showmode
set hls
noh
set incsearch
set linebreak
set ignorecase
set smartcase
set magic
set matchtime=2
set switchbuf=useopen
set splitbelow
set splitright
set display=lastline
set hidden
" set fileformat=unix
set title

if !isdirectory($VICONFDIR) | call mkdir($VICONFDIR, '', 0770) | endif
" Handle backups
if !isdirectory($VICONFDIR . "/bak") | call mkdir($VICONFDIR . "/bak", '', 0700) | endif
silent ! find $VICONFDIR/bak -type f -mtime +30 -delete
set backupdir=$VICONFDIR/bak
set undodir=$VICONFDIR/bak
set undofile
set directory=$VICONFDIR/bak
set swapfile
set sessionoptions+=globals
set history=2500
set viminfofile=$VICONFDIR/viminfo

set t_Co=256
"  if $TERMINAL == 'xterm' | set term=xterm-256color | endif
if $TERMINAL =~ 'kitty' | let &t_ut='' | endif

if has('mouse') | set mouse=a | endif
if &t_Co > 2 || has("gui_running")
  syntax on
  let c_comment_strings=1
endif

augroup Sessload
  autocmd!
  " async call function after few ms
  autocmd SessionLoadPost * call timer_start( 5, {-> ReloadStyle(1)} )
  " call timer_start(100, {-> execute("colo dayfox")})
augroup END
augroup SaveNotes
  autocmd!
  autocmd FocusLost silly.txt silent update
  autocmd BufLeave  silly.txt silent update
augroup END

augroup myAucmds
  au!
  set updatetime=6000
  autocmd CursorHold * normal! m'
  " autocmd FocusGained,BufEnter,CursorHold * :silent! checktime
  autocmd FocusGained,BufEnter,CursorHold * : checktime
  autocmd FileChangedShell * echo "Message: File changed on disk"
augroup END

" autocmd BufWritePre *.js lua vim.lsp.buf.formatting_sync(nil, 100)|\
" autocmd SessionLoadPost * echom "Welcome back"
autocmd WinNew * set numberwidth=2
autocmd FileType c setlocal commentstring=//%s
autocmd FileType cpp setlocal commentstring=//%s
autocmd FileType text setlocal commentstring=#%s
autocmd FileType cmake setlocal commentstring=#%s
autocmd FileType c setlocal colorcolumn=0
" autocmd CursorHold * normal! m'

" " Taming netrw
" autocmd FileType netrw setl bufhidden=wipe
" " autocmd FileType netrw setl bufhidden=delete
" augroup my_netrw_mapping
"     autocmd!
"     autocmd filetype netrw call MyNetrwMapping()
" augroup END
" function! MyNetrwMapping()
"     noremap <buffer> x :q<cr>
"     nnoremap <buffer> a <Nop>
" endfunction
" let g:netrw_banner = 0
" let g:netrw_liststyle = 3
" let g:netrw_browse_split = 0
" let g:netrw_altv = 1
" let g:netrw_winsize = 25
" make vim-sneak respect netrw
let g:sneak#map_netrw = 0

if executable('rg')
  set grepprg=rg\ --smart-case\ --vimgrep\ --follow\ --no-ignore\ -g\ '!tags'
  " Output of :grep should go to cwindow
  autocmd QuickFixCmdPost *grep* cwindow
elseif executable('ag')
endif

" Remember last tab to use it later!
if !exists("g:lasttab")
  let g:lasttab = 1
endif
autocmd TabLeave * let g:lasttab = tabpagenr()

""  Plugin specific setttings  ""

let g:GPGPreferSymmetric=1
set foldmethod=marker
let g:UltiSnipsSnippetDirectories=[$HOME."/.vim/ultisnips"]
let g:solarized_termcolors=256
let xterm16_brightness = '#aac8c2' | let xterm16_colormap='soft'
let g:seoul256_background = 234
let g:deoplete#enable_at_startup = 1

" let g:SrcExpl_pluginList = [ "__Tag_List__" ]
" let g:ScrExpl_refreshTime=200
" let g:SrcExpl_winHeight = 13

if has("cscope")
  " set cscopetag
  set csto=0
  if filereadable("cscope.out")
    cs add cscope.out
  elseif $CSCOPE_DB != ''
    cs add $CSCOPE_DB
  endif
  set cscopeverbose
  nmap <C-@>s :cs find s <C-R>=expand("<cword>")<CR><CR>
  nmap <C-@>g :cs find g <C-R>=expand("<cword>")<CR><CR>
  nmap <C-@>c :cs find c <C-R>=expand("<cword>")<CR><CR>
  nmap <C-@>t :cs find t <C-R>=expand("<cword>")<CR><CR>
  nmap <C-@>e :cs find e <C-R>=expand("<cword>")<CR><CR>
  nmap <C-@>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
  nmap <C-@>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
  nmap <C-@>d :cs find d <C-R>=expand("<cword>")<CR><CR>
  nmap <C-@>S :scs find s <C-R>=expand("<cword>")<CR><CR>
  nmap <C-@>G :scs find g <C-R>=expand("<cword>")<CR><CR>
  nmap <C-@>C :scs find c <C-R>=expand("<cword>")<CR><CR>
  nmap <C-@>T :scs find t <C-R>=expand("<cword>")<CR><CR>
  nmap <C-@>E :scs find e <C-R>=expand("<cword>")<CR><CR>
  nmap <C-@>F :scs find f <C-R>=expand("<cfile>")<CR><CR>
  nmap <C-@>I :scs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
  nmap <C-@>D :scs find d <C-R>=expand("<cword>")<CR><CR>
endif

""""""""""""""""""""""""""""""""
""          NeoVim:           ""
""""""""""""""""""""""""""""""""

function! CrispBorders()
  if !has("nvim")
    return
  endif
  set laststatus=3
  highlight WinSeparator guibg=none
  highlight WinSeparator guifg=#5a5a5a
endfunction

if has("nvim")
  set winwidth=32
  set winminwidth=32
endif

function! ReloadStyle(force)
  if has("nvim")
    set laststatus=1
    highlight WinSeparator guibg=none
    highlight WinSeparator guifg=#5a5a5a
  endif
  " if color is already chosen and force!=true
  if a:force!=1 && ( exists("g:colors_name") && g:colors_name != 'habamax' )
    " load color again to avoid tabline rendering problem
    echom "reload color ".g:colors_name
    exec 'colo '.g:colors_name
  else
    " load saved color
    call SetPhase()
    echom "load color for ".g:phase
    silent call LoadColor()
  endif
  if has("nvim")
    lua if H.is_available("tint") then H.reset("tint") end
  endif
endfunction

""""""""""""""""""""""""""""""""
""         Mappings:          ""
""""""""""""""""""""""""""{{{}}}

set timeoutlen=330
set ttimeoutlen=20 " do not let <esc>x act as <a-x>
let g:AutoClosePumvisible = {"ENTER": '', "ESC": ''}
let mapleader = ""
" nnoremap q\
" nnoremap z' `

" Free <q> key
map q <Nop>
" map й q
nnoremap Q q
nnoremap qm @@
nnoremap ,m @

" Free <a> key
nnoremap a <Nop>
" map ф a
nnoremap aa a

" go back to normal mode with <j> double tap
imap jj <ESC>
imap оо <ESC>

" go to end-of-line
imap <C-e> <C-o>A

imap <A-b> <C-o>b
imap <A-f> <C-o>e
imap <C-l> <Right>

" add space right from cursor
imap <C-s> <space><left>

" double <esc> will switch off search highlighting
" nnoremap <silent> <Esc><Esc> <Esc>:noh<CR><Esc>

" <x> and <s> will delete to no buffer
noremap x "_x
noremap X "_X
noremap c "_c
noremap C "_C
" noremap s "_s

" Editing
nnoremap qo o<space><C-u><Esc>
nnoremap qi O<space><C-u><Esc>
nnoremap qu ~
nnoremap cx s
" swap two chars
nnoremap gx dlp
" add space char
nnoremap z<space> i<space><Esc>
" add space to word
nnoremap q<space> i <Esc>lwi <Esc>
" add space inside brackets
nnoremap a<space> ysib<space>
vnoremap <space> :<C-U>call AddSpaceSelection()<CR>
" allows to undo accidental CTRL-U in insert mode
inoremap <C-U> <C-G>u<C-U>
nnoremap dx 0"_D
nnoremap dX ^"_D
nnoremap dc "_d$
nnoremap d. "_dd
nnoremap d<space> :call DelSpace()<CR>
" add this line to the next line
nnoremap al ddpkJ
" start fat new line
nnoremap c. :call InsertSpacy()<CR>
" insert new line after current paragraph
" nnoremap c<CR> }:if (line(".") == line("$")) \| exec "normal o" \| endif<CR>O
nnoremap c<Down> :call EditAtEdge('down')<CR>
nnoremap c<Up>   :call EditAtEdge('up')<CR>
" edit at text start/finish of the buffer
nnoremap a<Up>   gg:call search('^.')\|call EditAtEdge('up')<CR>
nnoremap a<Down> G$:call search('^.','b')\|call EditAtEdge('down')<CR>

" extend line with -----
nnoremap q- o<esc>64A-<esc>kJ0<esc>60ld$0<esc>40l
nnoremap q= o<esc>64A=<esc>kJ0<esc>60ld$0<esc>40l
" add horiz line
nnoremap z- o<esc>64A-<esc>0<esc>60ld$0<esc>40l
" insert one char
nnoremap af :exec "normal i".nr2char(getchar())."\e"<CR>
nnoremap ag :exec "normal! a".nr2char(getchar())."\e"<CR>

" Move around
nnoremap <Down> gj
nnoremap <Up>   gk
vnoremap <Down> gj
vnoremap <Up>   gk
inoremap <Down> <C-o>gj
inoremap <Up>   <C-o>gk
nmap <C-c> <C-y>
noremap <C-e> 4<C-e>
noremap <C-y> 4<C-y>
nnoremap ,ze :call SwitchCE()<CR>
" jump last edit edges
nnoremap [e `[
nnoremap ]e `]
" select last changed/yanked text
nnoremap [] `[v`]
" jump last selection edges
nnoremap [v `<
nnoremap ]v `>
" navigate quickfix list
nnoremap q<Up>   :cprev<CR>
nnoremap q<Down> :cnext<CR>
" navigate location list
nnoremap <C-Up>   :lprev<CR>
nnoremap <C-Down> :lnext<CR>
" nnoremap ]l :lnext<cr>
" nnoremap [l :lprev<cr>
" navigate in diff mode
nnoremap <F2> [czz
nnoremap <F3> ]czz
if exists("g:loaded_sneak_plugin")
  nmap s <Plug>Sneak_s
  nmap S <Plug>Sneak_S
endif
noremap <A-n> 12<c-e>
noremap <A-p> 12<c-y>
noremap <C-n> 6j
noremap <C-p> 6k
nmap q1 100G
nmap q2 200G
nmap q3 300G
nmap q4 400G
map <c-j> <Plug>(edgemotion-j)
map <c-k> <Plug>(edgemotion-k)
" search such //comments//
nnoremap am /\s*\/\/.*\/\/$<CR>
" jump to blank or one-char lines
nnoremap <silent> gn :call search('^\(.\\|\(\s\)*\)$','W')<CR>
nnoremap <silent> gp :call search('^\(.\\|\(\s\)*\)$','bW')<CR>
onoremap <silent> gn :call search('^\(.\\|\(\s\)*\)$','W')<CR>
onoremap <silent> gp :call search('^\(.\\|\(\s\)*\)$','bW')<CR>
nnoremap gj <C-o>

" For vim-signature
" nmap ]s ]-
" nmap [s [-
" nnoremap m-       :<C-U>call signature#mark#Purge("all")<CR>
" nnoremap m<space> :<C-U>call signature#mark#Purge("line")<CR>

" Open and close files (buffers)
nnoremap aw :w<CR>
nnoremap <C-s> :w<CR>
nnoremap ,,w :wa<CR>
nnoremap ax :q<CR>
nnoremap ,x :q<CR>
nnoremap ,<del> :tabclose<CR>
nnoremap ,q :qa<CR>
nnoremap ,d :bd!<CR>
nnoremap ,bd :BDnJump<CR>
nnoremap ,i :diffthis \| wincmd w<CR>
nnoremap ,o :diffoff  \| wincmd w<CR>
nnoremap ,' :echo expand ('%') '.@.' getcwd()<CR>
nnoremap ,c. :exec "lcd! %:p:h" <bar> echo 'lcd2file @' getcwd()<CR>
nnoremap ,c, :call GetProjDir() <bar> exec "lcd! " . b:proj_dir <bar> echo 'lcd2proj @' getcwd()<CR>
nnoremap ,cg :call ClimbToDirWhere(".git/index",1) \| pwd<CR>
nnoremap ,cm :call ClimbToDirWhere("Makefile",1) \| pwd<CR>
nnoremap a<BS> :checktime<cr>
nnoremap q<BS> :enew<CR>
nnoremap z<BS> :e!<CR>
" open prev window in current window
nnoremap qp :exec "buffer " . winbufnr(winnr("#"))<CR>
" split open filename under cursor
nnoremap g.v :vsp <c-r><c-f><CR>
nnoremap g.s :sp <c-r><c-f><CR>
" open file under cursor in previous window
nnoremap g.p :wincmd p \| e <c-r><c-f><CR>
" split open current file location with netrw
nnoremap a-s :wincmd s \| e %:p:h<CR>
nnoremap a-v :wincmd v \| e %:p:h<CR>
nnoremap a_ :wincmd s \| e %:p:h<CR>
nnoremap a- :wincmd v \| e %:p:h<CR>
nnoremap as  :new<CR>
nnoremap av  :vnew<CR>
" nnoremap as  :new      \| lcd #:p:h \| echo expand ('%') '.@.' getcwd()<CR>
" nnoremap av  :vnew     \| lcd #:p:h \| echo expand ('%') '.@.' getcwd()<CR>
" nnoremap a-  : split <bar> exec "normal -"<CR>
" nnoremap a_  :vsplit <bar> exec "normal -"<CR>
nnoremap qs :split #<CR>
nnoremap qv :vsplit #<CR>
nnoremap <C-W>S :vsplit<CR>
nnoremap an :tabe %:p:h<CR>
" nnoremap ,. <C-^>
nnoremap <silent> ,. :if bufexists(bufnr('#')) <bar> b # <bar> echo expand('%') <bar> else <bar> echo 'No prev buffer.' <bar> endif<CR>
nnoremap ,by :call BufYank()<CR>
nnoremap ,bp :call BufPut()<CR>

" Handle windows
nnoremap qh     <C-w>h
nnoremap qj     <C-w>j
nnoremap qk     <C-w>k
nnoremap ql     <C-w>l
nnoremap <C-\>  <C-w>w
nnoremap a,     <C-w>6<
nnoremap a.     <C-w>6>
nnoremap ae     <C-w>4+
nnoremap ad     <C-w>4-
nnoremap ar     <C-w>_
nnoremap ac     <C-w>80-
" grow big
nnoremap ab     <C-w>_<C-w>\|
nnoremap ah     <C-w>=
nnoremap aj     <C-w>w<C-w>_
nnoremap ak     <C-w>W<C-w>_
" focus prev window
nnoremap g<space> <C-w>p
nnoremap q<tab> <C-w>p
" swap current and previous window
silent nnoremap c<tab> :call WinSwap() <bar> wincmd p<CR><Esc>
nnoremap \\     <C-w>T

" Handle tabs
nnoremap at :tabe<CR>
nnoremap aT :-tabe<CR>
nnoremap <C-PageUp> gT
nnoremap <C-PageDown> gt
nnoremap gz gT
nnoremap q] gt
nnoremap q[ gT
nnoremap <A-.> gt
nnoremap <A-,> gT
nnoremap q{ :tabmove -1<CR>
nnoremap q} :tabmove +1<CR>
nnoremap q< :call MoveToPrevTab()<CR>
nnoremap q> :call MoveToNextTab()<CR>
" select previous tab
nnoremap g<tab> :exe "tabn ".g:lasttab<CR>
nnoremap g1 1gt
nnoremap g2 2gt
nnoremap g3 3gt
nnoremap g4 4gt
nnoremap g5 5gt
nnoremap g6 6gt
nnoremap g7 7gt
nnoremap g8 8gt
nnoremap g9 9gt

" Find buffers/files
nnoremap ,bj :Unite buffer file<CR>
nnoremap ,bi :Unite buffer file<CR>i
nnoremap ,bk :Denite buffer -mode=normal -immediately-1<CR>
nnoremap ,be :BufExplorer<CR>
nnoremap ,,e :BufExplorer<CR>
nnoremap ,zf :Files<CR>
nnoremap ,zg :GFiles<CR>
nnoremap ,zl :Lines<CR>
nnoremap ,zs :Files $sh<CR>
nnoremap ,zt :Files $tt<CR>
nnoremap ,zj :Files $jo<CR>
command! -bang FilesProj call GetProjDir() <bar> call fzf#vim#files(expand(b:proj_dir), fzf#vim#with_preview({'options': ['--layout=reverse','--info=inline']}), <bang>0)
command! -bang MyTelescopeFilesProj call GetProjDir() <bar> exec 'Telescope find_files cwd=' . expand(b:proj_dir)
if has("nvim")
  nnoremap qf :MyTelescopeFilesProj<CR>
  nnoremap qF :Telescope find_files search_dirs=%:p:h<CR>
  nnoremap ,/ :Telescope find_files search_dirs=$sh,$tt,$loc<CR>
  nnoremap ,,/ :Telescope find_files theme=ivy search_dirs=$sh,$PWD
else
  nnoremap qf :FilesProj<CR>
  nnoremap qF :Files %:p:h<CR>
  nnoremap ,/ :Files $sh,$tt,$loc<CR>
  nnoremap ,/ :Files $sh<CR>
  nnoremap ,,/ :Files $sh
endif
" nnoremap ,fg :Telescope live_grep theme=ivy<CR>
" nnoremap ,fd :Telescope live_grep theme=ivy search_dirs=%<CR>
" nnoremap ,ff :Telescope find_files theme=ivy<CR>
" nnoremap ,fr :Telescope lsp_references<CR>
" nnoremap qr  :Telescope lsp_references<CR>
" nnoremap ,fs :Telescope lsp_document_symbols<CR>
" nnoremap qs  :Telescope lsp_dynamic_workspace_symbols<CR>
" " nnoremap ,<space> :Telescope buffers sort_mru=1 theme=dropdown winblend=9<CR>
" nnoremap ,fo :Telescope oldfiles<CR>
" nnoremap ,fz :Telescope diagnostics<CR>
" nnoremap ,fh :Telescope help_tags<CR>

" Jump to favourite files
nnoremap ,gv :call FocusBufOrDo('myvimrc','e $sh/vi/myvimrc')<CR>
if exists("g:vimplug_available")
  nnoremap ,gr :call FocusBufOrDo('vimrc_plug','e $sh/vi/vimrc_plug')<CR>
endif
nnoremap ,gt :call FocusBufOrDo('vimrc_themes','e $sh/vi/vimrc_themes')<CR>
nnoremap ,gc :call FocusBufOrDo('init.lua','e $mylua/init.lua')<CR>
nnoremap ,ga :call FocusBufOrDo('lsp.lua','e $mylua/lsp.lua')<CR>
nnoremap ,g, :call FocusBufOrDo('vimrc_main','e $sh/vi/vimrc_main')<CR>
nnoremap ,gb :call FocusBufOrDo('bashrc','e $sh/bashrc')<CR>
nnoremap ,gB :call FocusBufOrDo('bashrc.local','e $loc/bashrc.local')<CR>
nnoremap ,g2 :call FocusBufOrDo('bspwmrc','e $sh/bspwmrc')<CR>
nnoremap ,gx :call FocusBufOrDo('sxhkd','e $sh/conf/sxhkdrc')<CR>
nnoremap ,gk :call FocusBufOrDo('kitty.conf','e $sh/conf/kitty.conf')<CR>
nnoremap ,gz :call FocusBufOrDo('zzzz','e $tt/zzzzzz')<CR>
nnoremap ,gu :call FocusBufOrDo('ff','e $tt/u*/ff*')<CR>
nnoremap ,gh :call FocusBufOrDo('sh_history','e $HOME/.bash_history')<CR>G
nnoremap ,gl :call FocusBufOrDo('1linux','e $sh/rs/1linux')<CR>
nnoremap ,gm :call FocusBufOrDo('memo','e $sh/rs/1code.c')<CR>
" nnoremap q/  :call FocusWindowOrDo('silly.txt','1tabn \| wincmd b \| e $tbuf')<CR>
nnoremap ,gs :call FocusBufOrDo('silly.txt','e $tbuf')<CR>
nnoremap ,gw :call FocusBufOrDo('work.txt','e $wbuf')<CR>

nnoremap ,,<space> :Goyo<CR>
nnoremap ,vi :IndentBlanklineToggle<CR>

" Start and quit Vim
nnoremap ,V :source $MYVIMRC<CR>
nnoremap ,,v :source $MYVIMRC<CR>
nnoremap ,v<space> :source %<CR>
nnoremap c<BS> :call SetPhase() <bar> call LoadColor() <bar> call CrispBorders()<CR>
nnoremap ,,z :source $VICONFDIR/session/comon <bar> silent call AddRpcEar()<CR>
nnoremap ,,q :call SaveColor() <bar> SSave! comon <bar> qa<CR>
nnoremap ,,s :call SaveColor() <bar> SSave! comon<CR>
" nnoremap ,,s :call SaveColor() <bar> mksession! $VICONFDIR/session/comon<CR>
nnoremap ,vq :qa!<CR>
nnoremap ,<esc> :Startify<CR>
nnoremap ,zq :wa <bar> qa<CR>
nnoremap ,,a :call AddRpcEar()<CR>
" Open current file at vimserver session via my "vimrpc" shell script
nnoremap qza :silent exec '! vir "%:p"'<CR>
nnoremap qzz :exec '! vir "%:p"' \| q<CR>
nnoremap qzc :exec '! MODE=cur    vir "%:p"' \| q<CR>
nnoremap qzn :exec '! MODE=newtab vir "%:p"' \| q<CR>
nnoremap qzs :exec '! MODE=split  vir "%:p"' \| q<CR>
nnoremap qzv :exec '! MODE=vert   vir "%:p"' \| q<CR>

" Silly update git repo
map ,,g :call LGsync()<CR>

" Have mappings in terminal mode
if v:version >= 801
  tmap oo <C-w>N:set nonumber<CR>
  tmap o<C-o> <C-w>N :e #<CR>
  tmap <C-x> <C-w>N :BDnJump<CR>
  tnoremap <C-PageUp> <C-w>:tabprev<CR>
  tnoremap <C-PageDown> <C-w>:tabnext<CR>
  tnoremap g<tab> <C-w>:exe "tabn ".g:lasttab<CR>
  tnoremap q<tab> <C-w>p
  tnoremap <C-\> <C-w>w
endif
if has("nvim")
  tnoremap oo <C-\><C-n>
  tnoremap o<C-o> <C-\><C-n>:e #<CR>
  tnoremap <C-x> <C-\><C-n>:BDnJump<CR>
  tnoremap <C-PageUp> <C-\><C-n>:tabprev<CR>
  tnoremap <C-PageDown> <C-\><C-n>:tabnext<CR>
  tnoremap g<tab> <C-\><C-n>:exe "tabn ".g:lasttab<CR>
  tnoremap q<tab> <C-\><C-n>:wincmd p<CR>
  " tnoremap <A-Left> <C-\><C-N><C-w>h
  tnoremap <C-\> <C-\><C-n><C-w>w
  tnoremap <A-Down> <C-\><C-N><C-w>w
  tnoremap <A-Up> <C-\><C-N><C-w>W
  " tnoremap <A-Right> <C-\><C-N><C-w>l
  " inoremap <A-Left> <C-\><C-N><C-w>h
  inoremap <A-Down> <C-\><C-N><C-w>j
  inoremap <A-Up> <C-\><C-N><C-w>k
  " inoremap <A-Right> <C-\><C-N><C-w>l
  " nnoremap <A-Left> <C-w>h
  nnoremap <A-Down> <C-w>w
  nnoremap <A-Up> <C-w>W
  " nnoremap <A-Right> <C-w>l
endif

" Scroll fraction of the screen
let scrollpart=70
let key4=""
let key15=""
nnoremap <silent> <Space>   :exec 'normal! '.float2nr(round(winheight(0)*(exists("b:scrollpart") ? b:scrollpart : g:scrollpart)*0.01))."<C-d>"<CR>
nnoremap <silent> <BS>      :exec 'normal! '.float2nr(round(winheight(0)*(exists("b:scrollpart") ? b:scrollpart : g:scrollpart)*0.01)).key15<CR>
nnoremap <silent> <a-space> :exec 'normal! '.float2nr(round(winheight(0)*(exists("b:scrollpart") ? b:scrollpart : g:scrollpart)*0.01)).key15<CR>
" nnoremap <silent><CR>    :exec 'normal! '.float2nr(round(winheight(0)*(exists("b:scrollpart") ? b:scrollpart : g:scrollpart)*0.01))."<C-d>"<CR>
" nnoremap <silent> <tab>   :exec 'normal! '.float2nr(round(winheight(0)*(exists("b:scrollpart") ? b:scrollpart : g:scrollpart)*0.01)).key15<CR>

" Preserve jumplist
nnoremap <silent> H :<C-u>execute "keepjumps norm! " . v:count1 . "H"<CR>
nnoremap <silent> M :<C-u>execute "keepjumps norm! " . v:count1 . "M"<CR>
nnoremap <silent> L :<C-u>execute "keepjumps norm! " . v:count1 . "L"<CR>
nnoremap <silent> * :<C-u>execute "keepjumps norm! " . v:count1 . "*"<CR>
" nnoremap <silent> { :<C-u>execute "keepjumps norm! " . v:count1 . "{zt"<CR>
" nnoremap <silent> } :<C-u>execute "keepjumps norm! " . v:count1 . "}zt"<CR>
nnoremap <silent> n :<C-u>execute "keepjumps norm! " . v:count1 . "nzz"<CR>
nnoremap <silent> N :<C-u>execute "keepjumps norm! " . v:count1 . "Nzz"<CR>

" Handle copy registers
nnoremap ay "+yiW
" copy Vim copy register to system copy buffers
nnoremap qy :let @+ = @" <bar> :let @* = @"<CR>
nnoremap ai :put  *<CR>
nnoremap aI :put! *<CR>
nnoremap ao :put  +<CR>
nnoremap aO :put! +<CR>
" put select system buffer as single paragraph
nnoremap ap o<Esc>:put! *<CR>`[v`]:g/^$/d<CR>:noh<CR>
nnoremap aP o<Esc>:put! +<CR>`[v`]:g/^$/d<CR>:noh<CR>
" shrink selection into single paragraph
vnoremap <C-l> :g/^$/d<CR>:noh<CR>
" yank inline
nnoremap yc ^y$"+y$"*y$
" yank current file full path/name
nnoremap y. :let @" = expand('%:p')<CR>
" replace current word with register contents
nnoremap cp "_ciw<c-r>"<esc>
nnoremap co "_ciw<c-r>*<esc>
nnoremap cO "_ciw<c-r>+<esc>

" Commanding Vim
nnoremap q; :<up>
vnoremap q; :<up>
nnoremap cc :
cnoremap <C-a> <Home>
cnoremap <C-b> <C-Left>
cnoremap <C-t> <C-Right>

nnoremap ,; :6mes<CR>
" Eval yanked
nnoremap yq :@"<CR>
" Add Plug entry
nnoremap ,vp :put + <bar> exec "normal dfmxIPlug 'A'"<CR>==
" Evaluate one line as Vimscript
nnoremap ,v. yy:@"<CR>
" Evaluate a paragraph as Vimscript and re-run last command
nnoremap ,v<CR> yap:@"<CR>:<up><CR>
" Evaluate one line or one paragraph as Vimscript
nnoremap ,v, :call EvalThis()<CR>
" Evaluate a paragraph as Vimscript
nnoremap ,v; :let lastpos=line('.') <bar> exec "normal yap" <bar> @\" <bar> exec lastpos<CR>:echo "Evaluated current paragraph."<CR>
" Evaluate a paragraph as Lua
nnoremap ,vl :let lastpos=line('.') <bar> exec "normal yap" <bar> exec 'lua ' . expand(@") <bar> exec lastpos<CR>:echo "Evaluated current paragraph as Lua."<CR>

if !has('nvim')
  " Open current location with vifm within vim
  nnoremap ac :terminal ++close bash -c "INVIM=1 vifm %:p:h"<CR>
  nnoremap aC :vertical terminal ++close bash -c "INVIM=1 vifm %:p:h"<CR>
  nnoremap a; :terminal ++kill=term ++curwin ++close bash -c "INVIM=1 vifm %:p:h"<CR>
  nnoremap a: :tabe \| terminal ++kill=term ++curwin bash -c "INVIM=1 vifm #:p:h"<CR>
  " Split open terminal at current location
  nnoremap ab : new \| if isdirectory(expand('#:p:h')) \| lcd #:p:h \| endif \| terminal ++kill=term ++curwin ++norestore<CR>
  nnoremap aB : vnew \| if isdirectory(expand('#:p:h')) \| lcd #:p:h \| endif \| terminal ++kill=term ++curwin ++norestore<CR>
  " Open terminal at current location
  nnoremap qB : if isdirectory(expand('%:p:h')) \| lcd %:p:h \| endif \| terminal ++kill=term ++curwin ++norestore<CR>
endif

" Spawn a terminal outside vim
nnoremap ,,t :NewTermHere<CR>
" Spawn vifm in terminal outside vim
nnoremap ,,c :NewVifmHere<CR>

" Jump to terminal window
nnoremap <A-b> :call GotoTerm(0)<CR>

" Exec current paragraph with shell
nnoremap ,b; yap: exec "!" . @"<CR>

" Exec selection with shell
vnoremap ,b :call RunSelBash()<CR>

" Call system
" system open current path
nnoremap ,C :Silent xdg-open %:p:h &<CR>
" system open current file
nnoremap ,O :Silent xdg-open %:p &<CR>
" system open current line (usable for http links)
nnoremap ,,o ^y$:call system('xdg-open ' . "'" . @" . "'")<CR>
" system open selected lines
vnoremap ,,o :<C-U>call SystemOpenEveryLine()<CR>
" open current line with firefox
nnoremap ,e ^y$:call system('firefox ' . "'" . @" . "' &")<CR>
" google current line
nnoremap ,go ^y$:call system('google.sh ' . "'" . @" . "'")<CR>
" yandex current line
nnoremap ,gy ^y$:call system('yandex.sh ' . "'" . @" . "'")<CR>
" wiki current line
" nnoremap ,gr ^y$:silent exec " !source $HOME/.bashrc && chromium \"wiki " . @" . "\" &>/dev/null & " \| redraw!<CR>

" Appearance
nnoremap z; :set wrap!<CR>
nnoremap ,zz :let &scrolloff=28-&scrolloff<CR>
nnoremap ,zc :let &colorcolumn=80-&colorcolumn<CR>
nnoremap ,zn :set number!<CR>
nnoremap c<space> :set filetype=text<CR>
nnoremap ,vb :call SwitchBackground()<CR>:echo "background=" &background<CR>
nnoremap ,vc :set termguicolors!<CR>:set termguicolors?<CR>
nnoremap a/ :set hlsearch!<CR>
nnoremap ,vg :GitGutterToggle<CR>

" Tags
" nnoremap ,ct :TagbarOpen fj<CR>
" nnoremap ,* :silent exec 'UpdCtags' \| redraw! \| echo 'Wrote tags db in' getcwd().'/'<CR>
" nnoremap ,* :call UpdCtagsHereDeps()<CR>
" nnoremap ,* :call UpdCtagsGitDeps()<CR>
" nnoremap ,* :call UpdCtagsGit()<CR>

" Make and run project
nnoremap ,zo :make<bar> copen<CR>
nnoremap ,zd :call BuildProjectUni("my_Makefile","make -f my_Makefile distclean")
nnoremap ,zx :call BuildProjectUni("my_Makefile","make -f my_Makefile clean")<CR>
nnoremap ,zm :call BuildProjectUni("my_Makefile","make -f my_Makefile")<CR>
nnoremap ,zr :call BuildProjectUni("Makefile","make -f my_Makefile run")<CR>
nnoremap ,zb :call BuildProjectUni("my_Makefile","make -f my_Makefile bear")<CR>
" nnoremap ,XX :call BuildProjectUni("Makefile","make tags") <bar> cwindow<CR>
" nnoremap ,zm :lcd %:p:h <bar> call BuildProjectUni("Makefile","make -f my_Makefile") <bar> redraw! <bar> copen<CR>
nnoremap ,z/ :copen<CR>/error<CR>

" Folding
vnoremap ,cf :<C-U>call FoldSelection()<CR>
nnoremap ,cf :set opfunc=FoldMotion<cr>g@

" Save last insert as Macro at "l"
command! -nargs=1 LastToMacro exec "let @" . <q-args> . " = \"i\" . @. . \"<Esc>\""
nnoremap ,L :LastToMacro l<CR>

" Show current dir & current file stats
nnoremap ,zl : silent exec '! echo -e "\n$(pwd):"; ls -la . ; echo \. ; ls -la %:p ; read -n 1 -s -r -p "//hit.anykey" ; echo -ne "\n" ' \| redraw!<CR>

""""""""""""""""""""""""""""""""
""         Commands:          ""
""""""""""""""""""""""""""""""""

command! -nargs=1 Silent exec 'silent !' . <q-args> | exec 'redraw!'
  "Usage : Silent ls; read -rsn1 -p "//hit.anykey"; echo;

command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
          \ | wincmd p | diffthis

xnoremap ,E :<C-U> echo GetVisualSelectionSum(visualmode())<Cr>
function! GetVisualSelectionSum(mode)
  "" Call with visualmode() as the argument
  let [line_start, column_start] = getpos("'<")[1:2]
  let [line_end, column_end]     = getpos("'>")[1:2]
  " Allign to order
  if line_start > line_end
    let z = line_start
    let line_start = line_end
    let line_end = z
  endif
  if column_start > column_end
    let z = column_start
    let column_start = column_end
    let column_end = z
  endif
  let lines = getline(line_start, line_end)
  if a:mode ==# 'v'
    " Must trim the end before the start, the beginning will shift left.
    let lines[-1] = lines[-1][: column_end - (&selection == 'inclusive' ? 1 : 2)]
    let lines[0] = lines[0][column_start - 1:]
  elseif  a:mode ==# 'V'
    " Line mode no need to trim start or end
  elseif  a:mode == "\<c-v>"
    " Block mode, trim every line
    let new_lines = []
    let i=0
    for line in lines
      let lines[i] = line[column_start - 1: column_end - (&selection == 'inclusive' ? 1 : 2)]
      let i = i + 1
    endfor
  else
    return ''
  endif
  let i=0
  for line in lines
    if line =~ '[1234567890]' && line != '.'
      " echom line
    else
      let lines[i] = '0'
    endif
    let i = i + 1
    " echom line
  endfor
  " return join(lines, "\n")
  " return join(lines, "+")
  return eval(substitute(join(lines,"+"),',','.',"g"))
  " return substitute(join(lines,"+"),',','.',"g")
endfunction

" Sum lines of numbers in range
command! -range Sum :echo eval(substitute(join(getline(<line1>,<line2>),'+'),',','.',"g"))

command! SuW w !sudo tee %
command! SuE r !sudo cat %
command! Fdel :silent exec '!rm %' | redraw! | bd
command! KIR e ++enc=cp1251 | set fileencoding=utf-8 | set fileformat=unix
command! KIRdos e ++enc=cp1251 | set fileencoding=utf-16 | set fileformat=dos
" command! C1KIR e ++enc=cp1251 | set fileencoding=utf-8 | set fileformat=unix | wq
command! F set fileencoding=utf-8 | set fileformat=unix

function! RunSelBash()
  echo system(join(getline(a:firstline,a:lastline), "\n"))
endfunction

" command! SessWriteA call SaveColor() | call TerminalsFuneral() | mksession! $VICONFDIR/session.vim | SaveSigns! $VICONFDIR/signs.sav
" command! SessWriteB exec 'SessWriteA' | call BufFocusedThenDo('signs.sav','wq')

command! Bash exec 'silent ! bash' | redraw!
command! NewTerm exec 'silent ! $TERMINAL &' | redraw!
command! NewTermHere exec 'silent ! cd "%:p:h" && $TERMINAL &' | redraw!
command! NewVifmHere exec 'silent ! $TERMINAL -e vifm --select %:p & ' | redraw!
command! LCDhere lcd! %:p:h | pwd
command! LCDrealpath let b:cwd = expand("%:p:h") | let b:rcwd = system("realpath " . b:cwd) | exec "lcd! " . b:rcwd

command! FollowSymLink let b:symlink = expand("%:p") | execute "file " . resolve(expand("%")) | edit
command! UnFollowSymLink exec 'file ' . b:symlink | edit

command! UpdCtags !ctags -R --exclude=.git --exclude=log --exclude=wutils --c++-kinds=+p --fields=+iaS --extra=+q *
command! UpdCtagsSudo !sudo ctags -R --exclude=.git --exclude=log --exclude=wutils --c++-kinds=+p --fields=+iaS --extra=+q *

command! Yall %y "
command! Dall %d _
command! Call %d _ | put!
command! SwapContentPrevWin :call SwapContentPrevWin()

""""""""""""""""""""""""""""""""
""         MS_stuff:          ""
""""""""""""""""""""""""""""""""

if !empty($WINDIR)
" If windows
  " set makeprg=\./make.bat
  " set makeprg=\./make.bat\ -j4\ DEBUG=1
  " nnoremap qp :put +<CR>j
    command! RCbash :exec '!source /c/Users/user/.bashrc'
    command! NewTerm exec 'silent ! mintty.exe &' | redraw!
    command! UpdCtags !ctags.exe -R --exclude=.git --exclude=log --exclude=wutils --c++-kinds=+p --fields=+iaS --extra=+q *
  command! Chrome :silent exec '!source /c/Users/user/.bashrc && chrome "%"' | redraw!
  command! Npp :silent exec '!source /c/Users/user/.bashrc && npp "%"' | redraw!
  command! XYp :silent exec '!source /c/Users/user/.bashrc && exp "%:p:h" &' | redraw!
endif

""""""""""""""""""""""""""""""""
""           Menus:           ""
""""""""""""""""""""""""""""""""

set wildmenu
set wcm=<tab>
map ,<tab> :emenu tagi.<tab>
" menu tagi.ru :setlocal spell spelllang=ru<CR>
menu tagi.basic   :silent exec 'UpdCtags' \| redraw! \| echo 'Wrote tags db in' getcwd().'/'<CR>
menu tagi.dirDeps :call UpdCtagsDirDeps()<CR>
menu tagi.gitDeps :call UpdCtagsGitDeps()<CR>
menu tagi.git     :call UpdCtagsGit()<CR>

""""""""""""""""""""""""""""""""
""          Macros:           ""
""""""""""""""""""""""""""""""""

" press ,mgg to write yank reg to tbuf file
let @g = ",gsGzk4k\<C-k>jzzao:call DoOnKey(\"103\",\"b #\")\n"
" put spaces around current char
let @s = "i \<Esc>ll."

""""""""""""""""""""""""""""""""
""         Functions:         ""
""""""""""""""""""""""""""{{{}}}

function! EditAtEdge(dir)
  " Go to edge of text/blank area and insert new line there
  let regex_blank = '^.'
  let regex_nonempty = '^$'
  if getline(line('.')) =~ "^$"
    let target_regex = regex_blank
    let m1 = 1
  else
    let target_regex = regex_nonempty
    let m1 = 0
  endif
  if a:dir == 'up'
    let m2 = 1
    if !search(target_regex,'bW')
      let m2 = !m2
      normal {
    endif
  elseif a:dir == 'down'
    let m2 = 0
    if !search(target_regex,'W')
      let m2 = !m2
      normal }
    endif
  endif
  if m1 == 1
    " Step back into blank area
    if a:dir == 'up'
      normal j
    elseif a:dir == 'down'
      normal k
    endif
  endif
  " let mor = xor(m1,m2)
  echom m2
  if m2 == 1
    put = ''
  else
    put! = ''
  endif
  startinsert
endfunc

function! LGstamp(...)
  exec "lcd! " . GetProjDir()
  if system('ls -d .git/ >/dev/null || echo 1')
    echom "Can't find .git location!"
    return -1
  endif
  if system('git status|grep -c "nothing to commit"')
    echo "nothing to commit"
  else
    G add .
    if ( a:0 > 0 )
      exec "G commit -m" . a:1
    else
      G commit -m "---"
    endif
  endif
endfunc
command! -nargs=? LGstamp call LGstamp(<f-args>)

function! LGsync()
  exec "lcd! " . GetProjDir()
  if system('ls -d .git/ >/dev/null || echo 1')
    echom "Can't find .git location!"
    return -1
  endif
  G add .
  G commit -m "---"
  G pull
  if system('git status|grep -c "publish your local"')
    G push
  else
    echo "Nothing to push"
  endif
endfunc

function! RunSelBash()
  echo system(join(getline(a:firstline,a:lastline), "\n"))
endfunction

function! UpdCtagsDirDeps()
  echom "Trying to update ctags with deps in this directory"
  silent exec '! echo -e "\n\n"Trying to update ctags with deps in this directory"..."'
  exec '! $sh/ctags_with_deps.sh $(find . -type f -name \*.[ch])'
endfunction

function! UpdCtagsGitDeps()
  echom "Trying to update ctags with deps in this git project"
  silent exec '! echo -e "\n\n"Trying to update ctags with deps in this git project"..."'
  let l:starting_directory = getcwd()
  let l:curr_directory = expand('%:p:h')
  exec "cd " . l:curr_directory
  let l:proj_dir = ClimbToDirWhere(".git/index",1)
  if ( l:proj_dir != "-1" )
    silent exec '! echo Found .git in $PWD/'
    " exec '!ctags -R --exclude=.git --exclude=log --exclude=wutils --c++-kinds=+p --fields=+iaS --extra=+q *'
    exec '! $sh/ctags_with_deps.sh $(find . -type f -name \*.[ch])'
  else
    echom "Cant find .git"
  endif
  exec "cd " . l:starting_directory
endfunction

function! UpdCtagsGit()
  echom "Trying to update ctags in this git project"
  silent exec '! echo -e "\n\n"Trying to update ctags in this git project"..."'
  let l:starting_directory = getcwd()
  let l:curr_directory = expand('%:p:h')
  exec "cd " . l:curr_directory
  let l:proj_dir = ClimbToDirWhere(".git/index",1)
  if ( l:proj_dir != "-1" )
    silent exec '! echo Found .git in $PWD/'
    exec '!ctags -R --exclude=.git --exclude=log --exclude=wutils --c++-kinds=+p --fields=+iaS --extra=+q *'
  else
    echom "Cant find .git"
  endif
  exec "cd " . l:starting_directory
endfunction

function! AddRpcEar()
  echo "Will launch an rpc server with default address for this editor.."
  if has("nvim")
    if empty($NVIMSERV)
      echom "NO way! Rpc address for neoVim not provided"
    elseif filereadable(expand($NVIMSERV))
      echom "NO way! Desired RPC address is already taken -- " . expand($NVIMSERV)
    else
      call serverstart(expand($NVIMSERV))
    endif
  elseif v:version >= 800
    if !empty($VIMSERV)
      if empty(v:servername)
        call remote_startserver(expand($VIMSERV))
      else
        echom "Sorry, this Vim instance already runs an rpc server"
      endif
    else
      echom "Rpc address for Vim not provided"
    endif
  endif
endfunction

function! BuildProject1()
  let l:starting_directory = getcwd()
  let l:curr_directory = expand('%:p:h')
  exec "cd " . l:curr_directory
  exec '!echo -e "\n"============ $(date) ============"\n"@ $PWD'
  make
  exec '!echo -e "==Done build==\n"'
  exec "cd " . l:starting_directory
endfunction

" function! MakeClean()
"   silent exec '!echo -e "\n=-=-=-=-=-=-=-=-=-=-=-=-=-="'
"   silent exec "!make clean"
"   redraw!
" endfunction

function! BuildProjectUni(Makefile,Makecommand)
  " exec "!echo " . a:Makecommand . ":"
  " memorize stuff
  let makeprg_bak = &makeprg
  let &makeprg = a:Makecommand
  let starting_directory = getcwd()
  let curr_directory = expand('%:p:h')
  " change directory
  exec "lcd! " . curr_directory
  let proj_dir = ClimbToDirWhere(a:Makefile,1)
  " " !!! ignore cmake-generated Makefile
  while filereadable("vim_make_ignore")
    cd ../
    let proj_dir = ClimbToDirWhere(a:Makefile,1)
  endwhile
  if ( proj_dir != "-1" )
    if has("nvim")
      echo system("echo -e \"\\n\\n\"--" . a:Makecommand . " @ " . proj_dir . ":")
      echo system("echo ------------------------------------------------")
      make
    else
      silent exec "!echo -e \"\\n\\n\"--" . a:Makecommand . " @ " . proj_dir . ":"
      silent exec "!echo ------------------------------------------------"
      silent make
    endif
    " exec '! ' . a:Makecommand
  else
    exec '! echo Makefile not found!'
    echo "Makefile not found!"
  endif
  " reset stuff
  silent exec "lcd! " . starting_directory
  let &makeprg = makeprg_bak
  " exit with rituals
  if !has("nvim")
    Silent read -n 1 -s -r -p "//hit.anykey" ; echo -ne "\n\n"
    redraw!
  endif
endfunction

function! ClimbToDirWhere(filename,chdir)
  let init_dir = getcwd()
  exec "lcd! " . expand('%:p:h')
  while 1
    " Check if the file exists in the current directory
    if filereadable(a:filename)
      let result = getcwd()
      " Change directory if chdir==1
      if a:chdir !=# 1
        exec "lcd! " . init_dir
      endif
      return result
      " If we've hit the top level directory, break out
    elseif getcwd() ==# "/" || getcwd() =~# '^[^/]..$'
      exec "lcd! " . init_dir
      return -1
    else
      lcd! ..
    endif
  endwhile
  exec "lcd! " . init_dir
endfunction

function! GetProjDir()
  let proj_dir = ClimbToDirWhere("_proj_root",0)
  if ( proj_dir == -1 )
    let proj_dir = ClimbToDirWhere(".git/index",0)
  endif
  if ( proj_dir == -1 )
    let proj_dir = ClimbToDirWhere(".gitignore",0)
  endif
  if ( proj_dir == -1 )
    let proj_dir = ClimbToDirWhere("Makefile",0)
  endif
  if ( proj_dir == -1 )
    let proj_dir = expand('%:p:h')
  endif
  let b:proj_dir = proj_dir
  return proj_dir
endfunction

function! FocusBufOrDo(name,cmd)
  if buflisted(bufname(a:name))
    call FocusWindow(a:name)
    if bufname('%') != bufname(a:name)
      exec 'buffer ' . a:name
    endif
  elseif !empty(a:cmd)
    " echo 'No such buffer'
    exec a:cmd
  endif
endfunction

function! BufFocusedThenDo(name,cmd)
  if bufname('%') =~ a:name
    exec a:cmd
  else
    echo 'Not current buffer'
  endif
endfunction

function! FocusWindowOrDo(name,cmd)
  for b in getbufinfo()
    if b.name =~ a:name && !empty(b.windows)
      call win_gotoid(b.windows[0])
      return
    endif
  endfor
  echo 'Window not found'
  if !empty(a:cmd)
    exec a:cmd
  endif
endfunction

function! FocusWindow(name)
  for b in getbufinfo()
    if b.name =~ a:name && !empty(b.windows)
      call win_gotoid(b.windows[0])
      return
    endif
  endfor
endfunction

function! GotoTerm(arg)
  let cur = getbufinfo(expand('%'))[0].windows[0]
  let ar = []
  for b in getbufinfo()
    if b.name =~ '/bin/bash' && !empty(b.windows)
      let ar = ar + [b.windows[0]]
    endif
  endfor
  if len(ar) == 0
    " Should I create new window?
    if a:arg == 1
      wincmd n
    endif
    call FocusBufOrDo('/bin/bash','echo "No terminal found."')
    " call FocusBufOrDo('/bin/bash','echo "A new terminal!" | terminal ++curwin ++norestore')
    return
  endif
  " if ( exists("g:lasttermid") && (index(ar,cur)<0) )
  "   " echo 'remem' g:lasttermid
  "   call win_gotoid(g:lasttermid)
  "   return
  " endif
  call win_gotoid(ar[(1+index(ar,cur)) % len(ar)])
  " let g:lasttermid = getbufinfo(expand('%'))[0].windows[0]
endfunction

function! TerminalsFuneral()
  let bufmap = map(range(1, bufnr('$')), '[getbufvar((v:val), "&buftype"), v:val]')
  " echo bufmap
  let targ = filter(bufmap, 'v:val[0] =~ "terminal"')
  " echo targ
  for el in targ
    " echo el[1]
    " call term_setrestore(el[1],"++kill=term")
    call term_setkill(el[1],"term")
  endfor
endfunction

" echo map(range(1, bufnr('$')), '[bufname(v:val), v:val]')

" function! RevealBuf(arg)
"   let ar = []
"   for b in getbufinfo()
"     if b.name =~ a:arg && empty(b.windows) && b.loaded == 1
"       let a = b.bufnr
"       " echo b.bufnr
"       exec "sb" . (b.bufnr)
"     endif
"   endfor
" endfunction

function! RevealWindowOnTab(arg)
  let tabnum = tabpagenr()
  for bufnum in tabpagebuflist()
    if bufname(bufnum) =~ a:arg
      for buf in getbufinfo(bufnum)
        for bw in buf.windows
          if win_id2tabwin(bw)[0] == tabnum
            call win_gotoid(bw)
            return 1
          endif
        endfor
      endfor
    endif
  endfor
endfunction

function! RaiseNetRW()
  let r = RevealWindowOnTab("NetRWTreeListing")
  if r != 1
    exec "Vexplore"
  endif
endfunction

function! MoveToPrevTab()
  " there is only one window
  if tabpagenr('$') == 1 && winnr('$') == 1
    return
  endif
  " preparing new window
  let tab_nr = tabpagenr('$')
  let cur_buf = bufnr('%')
  if tabpagenr() != 1
    close!
    if tab_nr == tabpagenr('$')
      tabprev
    endif
    sp
  else
    close!
    exe "0tabnew"
  endif
  " opening current buffer in new window
  exe "b".cur_buf
endfunc

function! MoveToNextTab()
  "there is only one window
  if tabpagenr('$') == 1 && winnr('$') == 1
    return
  endif
  "preparing new window
  let tab_nr = tabpagenr('$')
  let cur_buf = bufnr('%')
  if tabpagenr() < tab_nr
    close!
    if tab_nr == tabpagenr('$')
      tabnext
    endif
    sp
  else
    close!
    tabnew
  endif
  "opening current buffer in new window
  exe "b".cur_buf
endfunc

" Swap content of 2 windows
function! SwapContentPrevWin()
  let lines1 = getline(1, '$')
  exe 'wincmd p'
  let lines2 = getline(1, '$')
  exe '%d_'
  $put=lines1
  normal ggdd
  exe 'wincmd p'
  exe '%d_'
  $put=lines2
  normal ggdd
endfunction

function! BufYank()
  let g:bufnra = bufnr("%")
endfunction

function! BufPut()
  exec "b" . g:bufnra
endfunction

function! WinSwap()
  " Swap current window with last used window
  let thiswin = winnr()
  let thisbuf = bufnr("%")
  let lastwin = winnr("#")
  let lastbuf = winbufnr(lastwin)
  exec lastwin . " wincmd w" ."|".
        \ "buffer ". thisbuf ."|".
        \ thiswin ." wincmd w" ."|".
        \ "buffer ". lastbuf
endfunction

function! SwitchBackground()
  if (&background == "light")
    exec "set background=dark"
  else
    exec "set background=light"
  endif
  " exec "set background"
  " echo &background
endfunction

function! SetPhase(...)
  " Discover what time of day it is by arg or by file-hint
  if ( a:0 > 0 )
    let g:phase = a:1
  elseif filereadable('/tmp/now_is_day')
    let g:phase = 'day'
  elseif filereadable('/tmp/now_is_nox')
    let g:phase = 'nox'
  elseif !exists("g:phase")
    let g:phase = 'dunno'
  endif
  " echom 'so phase is ' . g:phase
endfunction
function! SaveColor(...)
  if ( a:0 > 0 )
    let arg = a:1
  else
    let arg = g:phase
  endif
  if arg == 'day' || arg == 'dunno'
    echom "Saving colors for 'day'"
    let g:ColorDayName = g:colors_name
    if exists("g:loaded_lightline")
      let g:ColorDayLine = g:lightline.colorscheme
    endif
    let g:ColorDayBg = &background
  elseif arg == 'nox'
    echom "Saving colors for 'nox'"
    let g:ColorNoxName = g:colors_name
    if exists("g:loaded_lightline")
      let g:ColorNoxLine = g:lightline.colorscheme
    endif
    let g:ColorNoxBg = &background
  else
    echom "Please provide 'day' or 'nox'"
  endif
endfunction

function! LoadColor(...)
  if ( a:0==0 )
    let l:switch = g:phase
  else
    let l:switch = a:1
  endif
  let l:wanted_color = ''
  " return
  " if wanted_color == 0
  "   echo 'wc0q'
  " endif
  " echo ' '
  if l:switch=='dunno'
    echo "Will load very default colors."
    if exists("g:colors_name") | unlet g:colors_name | endif
    source $sh/vi/vimrc_themes
  elseif l:switch=='day'
    if !exists("g:ColorDayName")
      echom "NO saved colors for this phase of day! Loading defaults..(day)"
      if exists("g:colors_name") | unlet g:colors_name | endif
      source $sh/vi/vimrc_themes
    else
      " exec "colo " .  g:ColorDayName
      let wanted_color = g:ColorDayName
      if exists("g:loaded_lightline")
        exec "LineColor " .  g:ColorDayLine
      endif
      exec "set background=" . g:ColorDayBg
    endif
    let l:llcol = exists("g:ColorDayLine") ? g:ColorDayLine : 'none'
    " echo "phase=" . l:switch . ", color=" . g:ColorDayName . ", linecolor=" . l:llcol
  elseif l:switch=='nox'
    if !exists("g:ColorNoxName")
      echom "NO saved colors for this phase of day! Loading defaults..(nox)"
      if exists("g:colors_name") | unlet g:colors_name | endif
      source $sh/vi/vimrc_themes
    else
      " exec "colo " .  g:ColorNoxName
      let wanted_color = g:ColorNoxName
      if exists("g:loaded_lightline")
        exec "LineColor " .  g:ColorNoxLine
      endif
      exec "set background=" . g:ColorNoxBg
    endif
    let l:llcol = exists("g:ColorNoxLine") ? g:ColorNoxLine : 'none'
    " echo "phase=" . l:switch . ", color=" . g:ColorNoxName . ", linecolor=" . l:llcol
  else
    echo "Unknown phase of day!"
  endif
  if  wanted_color != ''
    exec "colo " .  wanted_color
    echo ' '
    echo "phase=" . l:switch . ", color=" . wanted_color . ", linecolor=" . l:llcol
  endif
endfunction
command! -nargs=? SaveColor call SetPhase(<f-args>) <bar> call SaveColor(<f-args>)
command! -nargs=? LoadColor call SetPhase(<f-args>) <bar> call LoadColor(<f-args>) <bar> call CrispBorders()

function! SwitchCE()
  if mapcheck("<C-e>") == ''
    noremap <C-e> 6<C-e>
    noremap <C-y> 6<C-y>
    echo "Now scrolling is faster."
  else
    unmap <C-e>
    try
      unmap <C-y>
    endtry
    echo "Now scrolling step is one line."
  endif
endfunc

function! LightlineReload(arg)
  if !exists("g:loaded_lightline")
    if has("nvim")
      "just escape
      return
    else
      echom "Please load lightline before this. Escaping.."
      return
    endif
  endif
  " '1' to reload the current theme when you edit its file
  " '' to print name of current theme
  if a:arg != ''
    if a:arg == '1'
      source %
    else
      let g:lightline.colorscheme = a:arg
      " let g:lightline = { 'colorscheme': a:arg }
    endif
  else
    echo g:lightline
  endif
  call lightline#init()
  call lightline#colorscheme()
  call lightline#update()
endfunction
command! -nargs=? LineColor call LightlineReload('<args>')

" Add few lines and start Insert mode
function! InsertSpacy()
  " check if current line is empty
  if getline('.') =~ '^\s*$'
    put = ''
    put! = ''
    startinsert
  else
    put = ''
    put! = ''
    put = ''
    startinsert
  endif
endfunction

" Delete bunches of blank lines
function! DelSpace()
  let cur = line('.')
  " Search end of previous paragraph
  let beg = search('\S$\n\(^\s*$\n\)\+','bW')
  let beg = ( beg + 1 )
  exec (cur)
  " Search end of blank space after current paragraph
  let fin = search('\(^\s*$\n\)\+','eW')
  if fin == 0 | let fin = line('$') | endif
  " echom "fin" (fin)
  " echom (fin-beg)
  if (fin-beg+1) > 0
    silent exec (beg)','(fin)'d'
  endif
  if ( line(".") == line("$") )
    " end-of-file case
    exec "normal! o"
  else
    " exec "normal! O"
    put! = ''
  endif
endfunction

function! Parenthise()
  while ( line(".") != line("$") )
    if ( col('$') != 1 )
      normal 0i"
      normal A\n"
    endif
    normal j
  endwhile
endfunction

function! DoOnKey(keycode,command)
  let key = getchar()
  " echom key
  if ( key == a:keycode )
    exec a:command
  endif
endfunction

function! EvalThis()
    " echom "beginin"
  if getline(line('.')) =~ "^$"
    " If cursor is on a blank line, Eval next paragraph
    exec "normal! yap:@\"\<CR>"
    " echom "whole par"
  else
    " Eval current line
    " echom "one line"
    if getline(line('.')) =~ '^\%[\s]*["].*'
      " Ignore the comment sign <"> if it was detected
      exec "normal! 0^wy$:@\"\<CR>"
    else
      exec "normal! yy:@\"\<CR>"
    endif
  endif
endfunction

" Exec command with output to current buffer
function! ExPut(cmd)
  redir => message
  silent exec a:cmd
  redir END
  if empty(message)
    echoerr "no output"
  else
   " use "new" instead of "tabnew" below if you prefer split windows instead of tabs
    " tabnew
    " setlocal buftype=nofile bufhidden=wipe noswapfile nobuflisted nomodified
    silent put=message
  endif
endfunction
command! -nargs=+ -complete=command ExPut call ExPut(<q-args>)

" Delete buffer and load previous buffer, or just any other
function! BDnJump()
  "" if ( ( expand('#') == '' ) || ( expand('#') =~ '!/bin/bash' ) ) "" if ( expand('%') =~ '!/bin/bash' ) && ( expand('%') == expand('#') ) """ Current and prev buffers are terminals
  if ( bufexists(bufnr('#')) ) " Previous buffer is unset
    let cbn = bufnr('%')
    b # " jump to the previous buffer
    exec  'bd!' . cbn
  else
    let cbn = bufnr('%')
    bnext " jump to any other buffer
    exec  'bd!' . cbn
  endif
endfunction
command! BDnJump call BDnJump()

function! SortParagraphs() range
  exec a:firstline . "," . a:lastline . 'd'
  let @@=join(sort(split(substitute(@@, "\n*$", '', ''), "\n\n")), "\n\n")
  put!
endfunction

function! AddSpaceSelection()
  let beg = getpos("'<")
  let fin = getpos("'>")
  call setpos('.',fin)
  silent exec "normal! a\<CR>\<Esc>"
  let newfin = getpos('.')
  call setpos('.',beg)
  silent exec "normal! i\<CR>\<Esc>"
  let newbeg = getpos('.')
  " Restore selection
  exec "normal `>V`<"
  normal <Esc>
endfunction

function! FoldMotion(type)
  if a:type == 'line'
    let line = &commentstring[0] . "------------------------------"
    let foldbeg = split(&foldmarker,",")[0]
    let foldend = split(&foldmarker,",")[1]
    let start = getpos("'[")[-3]
    let finish = getpos("']")[-3]
    exec finish
    put  = line . foldend
    exec start
    put! = line . foldbeg
  endif
endfunction

function! FoldSelection()
  let line = &commentstring[0] . "------------------------------"
  let foldbeg = split(&foldmarker,",")[0]
  let foldend = split(&foldmarker,",")[1]
  silent exec "normal `>"
  silent put  = line . foldend
  silent exec "normal `<"
  silent put! = line . foldbeg
endfunction

function! SystemOpenEveryLine()
  silent exec "normal `>"
  let end = line('.')
  silent exec "normal `<"
  let beg = line('.')
  for lineno in range(beg, end)
    let line = getline(lineno)
    " Open line with its xdg program
    silent call system('xdg-open ' . "'" . line . "' &>/dev/null &")
  endfor
  " Restore selection
  exec "normal `>V`<"
endfunction

function! CleanEmptyBuffers()
  let buffers = filter(range(1, bufnr('$')), 'buflisted(v:val) && empty(bufname(v:val)) && bufwinnr(v:val)<0 && !getbufvar(v:val, "&mod")')
  if !empty(buffers)
    exe 'bw ' . join(buffers, ' ')
  endif
endfunction

" FZF
function! s:list_buffers()
  redir => list
  silent ls
  redir END
  return split(list, "\n")
endfunction
function! s:delete_buffers(lines)
  execute 'bwipeout' join(map(a:lines, {_, line -> split(line)[0]}))
endfunction
command! BufD call fzf#run(fzf#wrap({
  \ 'source': s:list_buffers(),
  \ 'sink*': { lines -> s:delete_buffers(lines) },
  \ 'options': '--multi --reverse --bind ctrl-a:select-all+accept'
\ }))
"
let $FZF_DEFAULT_OPTS = '--exact --layout=reverse'
"
function! Delete_buffers()
  let l:preview_window = get(g:, 'fzf_preview_window', &columns >= 120 ? 'right': '')
  let l:options = [
        \   '-m',
        \   '--tiebreak=index',
        \   '-d', '\t',
        \   '--prompt', 'Delete> '
        \ ]
  if len(l:preview_window)
    let l:options = extend(l:options, get(fzf#vim#with_preview(
          \   {"placeholder": "{2}"},
          \   l:preview_window
          \ ), 'options', []))
  endif
  return fzf#run(fzf#wrap({
        \ 'source':  map(
        \   filter(
        \     range(1, bufnr('$')),
        \     {_, nr -> buflisted(nr) && !getbufvar(nr, "&modified")}
        \   ),
        \   {_, nr -> s:format_buffer(nr)}
        \ ),
        \ 'sink*': {
        \   lines -> execute('bdelete ' . join(map(lines, {
        \     _, line -> substitute(split(line)[0], '^\[\|\]$', '', 'g')
        \   })), 'silent!')
        \ },
        \ 'options': l:options,
        \}))
endfunction
function! s:format_buffer(b)
  let l:name = bufname(a:b)
  let l:name = empty(l:name) ? '[No Name]' : fnamemodify(l:name, ":p:~:.")
  let l:flag = a:b == bufnr('')  ? '%' :
        \ (a:b == bufnr('#') ? '#' : ' ')
  let l:modified = getbufvar(a:b, '&modified') ? ' [+]' : ''
  let l:readonly = getbufvar(a:b, '&modifiable') ? '' : ' [RO]'
  let l:extra = join(filter([l:modified, l:readonly], '!empty(v:val)'), '')
  return substitute(printf("[%s] %s\t%s\t%s", a:b, l:flag, l:name, l:extra), '^\s*\|\s*$', '', 'g')
endfunction

""""""""""""""""""""""""""""""""
""           WTF...           ""
""""""""""""""""""""""""""""""""

" " Highlight lines via signs functionality
" function! MySigns()
"   highlight myboo ctermbg=3 ctermfg=0
"   highlight mywar ctermbg=1 ctermfg=0
"   sign define mybookmark text=>> linehl=myboo texthl=myboo
"   sign define mywarning  text=!> linehl=mywar texthl=mywar
"   nnoremap <F8> :exe ":sign place 777 line=" . line(".") ." name=mywarning file=" . expand("%:p")<CR>
"   nnoremap <F9> :exe ":sign place 666 line=" . line(".") ." name=mybookmark file=" . expand("%:p")<CR>
"   nnoremap <F10> :sign unplace<CR>
"   if filereadable("$VICONFDIR/signs.sav")
"     source $VICONFDIR/signs.sav
"   endif
" endfunc
" call MySigns()

" Remember folds ??
" au BufWinLeave * mkview
" au BufWinEnter * silent loadview
" "Powerline
" let $PYTHONPATH='/usr/lib/python3.6/site-packages'
" set laststatus=2
" let g:Powerline_symbols = "fancy"
" let g:LustyExplorerSuppressRubyWarning = 1

" set statusline+=%#warningmsg#
" set statusline+=%{SyntasticStatuslineFlag()}
" set statusline+=%*
" let g:syntastic_always_populate_loc_list = 1
" let g:syntastic_auto_loc_list = 1
" let g:syntastic_check_on_open = 1
" let g:syntastic_check_on_wq = 0

" augroup mysettings
" au FileType tex set wrap shiftwidth=2 softtabstop=2 expandtab
" augroup END

" for vim-bookmarks
let g:bookmark_no_default_key_mappings = 0
nmap mm <Plug>BookmarkToggle
nmap m<Space> <Plug>BookmarkAnnotate
nmap m/ <Plug>BookmarkShowAll
nmap m<Down> <Plug>BookmarkNext
nmap m<Up> <Plug>BookmarkPrev

let g:floaterm_keymap_new    = '<F7>'
let g:floaterm_keymap_prev   = '<F8>'
let g:floaterm_keymap_next   = '<F9>'
let g:floaterm_keymap_toggle = '<F12>'

" Highlight all ExtraWhitespaces
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
augroup MatchExtraWhitespace
  autocmd!
  " au BufWinEnter * if &modifiable==1 | match ExtraWhitespace /\s\+$/ | endif
" au InsertLeave * if &modifiable==1 | match ExtraWhitespace /\s\+$/ | endif
    " au BufWinEnter * if &modifiable==0 | call clearmatches() | endif
  autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
  if has("nvim")
    autocmd BufModifiedSet * if &modifiable==1 | match ExtraWhitespace /\s\+$/ | else | call clearmatches() | endif
  else
    autocmd BufWinEnter,InsertLeave * match ExtraWhitespace /\s\+$/
  endif
  autocmd BufWinLeave * call clearmatches()
augroup END

if has("nvim")
  autocmd TermOpen * startinsert
  " autocmd BufEnter * if &buftype == 'terminal' | startinsert | endif
  autocmd BufEnter * if &buftype == 'terminal' | call timer_start(5, {->execute( "if &buftype == 'terminal' | startinsert | endif" )}) | endif
endif

command! AuSaveCur exec 'autocmd BufLeave ' . @% . ' silent update'

function! s:JbzCppMan()
  let old_isk = &iskeyword
  setl iskeyword+=:
  let str = expand("<cword>")
  let &l:iskeyword = old_isk
  execute 'Man ' . str
endfunction
command! JbzCppMan :call s:JbzCppMan()
autocmd FileType cpp nnoremap <buffer>K :JbzCppMan<CR>

if has("nvim")
  set wildoptions=pum
  set pumblend=15
  set winblend=10
  autocmd TermOpen * setlocal scrollback=-1
endif

" Watch log with Vim " For Neovim use :terminal
" call job_start("tail -f /ln/ho/iLog", {'out_io':'buffer','out_name':'dummy'})

nnoremap <silent><A-;> <Cmd>exe v:count1 . "ToggleTerm"<CR>
tnoremap <silent><A-;> <C-\><C-n>:ToggleTermToggleAll<CR>

" set completeopt=menuone,noselect
set completeopt=menu,noselect

